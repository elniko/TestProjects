package ubpartner.logmanagement;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.List;
import org.jdom.Comment;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;
import ubpartner.logmanagement.commun.Constante;
import ubpartner.logmanagement.commun.ConstanteLevel;
import ubpartner.logmanagement.commun.ConstanteXmlLog;


/**
 * Class to generate log files.
 */
public final class LMOutputLog {

	/**
	 * Log file generated by log4j framework.
	 */
	private static File logdefault;

	/**
	 * Intermediate log file, will be deleted at the end.
	 */
	private static File logbkp;

	/**
	 * Constructor.
	 */
	protected LMOutputLog() {
		logdefault = new File(LMConfiguration.getOutpath());
		logbkp = new File(logdefault.getParent() + "/" + Constante.BACKUPNAME);
	}

	/**
	 * Generate all log files.
	 */
	protected static void outputlog() {

		if (isEmpty(logdefault)) {
			if (!isEmpty(new File(logdefault.getPath() + Constante.PURGEDNAME))) {
				logdefault = new File(logdefault.getPath()
						+ Constante.PURGEDNAME);
			}
		}
		backupLog();
		reformLog();
	}

	/**
	 * Back up log file generated by log4j framework to standard XML format.
	 */
	private static void backupLog() {
		
		
		Closeable resource = null;
		Closeable resource2 = null;
		try {
			Reader fr = new FileReader(logdefault);
			BufferedReader br = new BufferedReader(fr);
			resource = br;
			FileWriter fw = new FileWriter(logbkp);
			BufferedWriter bw = new BufferedWriter(fw);
			resource2 = bw;
			bw.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
			bw.newLine();
			bw.write("<log xmlns:log4j=\"http://log4j\">");
			bw.newLine();
			String readline = null;
			while ((readline = br.readLine()) != null) {
				if (!readline.equals("")) {
					bw.write(readline);
					bw.newLine();
				}
			}
			bw.write("</log>");
					
		} catch (IOException e) {
			System.out.println(e.getMessage());
		} finally {
			
				try {
					resource.close();
					resource2.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
		
		}
	}

	/**
	 * Back up log file generated by log4j framework.
	 * 
	 * @param backupFile - file to write backup into.
	 */
	private static void backupLog(final File backupFile) {
		try {
			FileReader fr = new FileReader(logdefault);
			BufferedReader br = new BufferedReader(fr);
			FileWriter fw = new FileWriter(backupFile);
			BufferedWriter bw = new BufferedWriter(fw);
			String readline = null;
			while ((readline = br.readLine()) != null) {
				bw.write(readline);
				bw.newLine();
			}
			br.close();
			fr.close();
			bw.flush();
			bw.close();
			fw.close();
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
	}

	/**
	 * Reform log file generated by log4j framework to UBPARTNER format.
	 */
	@SuppressWarnings("unchecked")
	private static void reformLog() {
		SAXBuilder sxb = new SAXBuilder();
		try {
			Document log = sxb.build(logbkp);
			Element root = log.getRootElement();
			Namespace nsLog4j = root.getNamespace(ConstanteXmlLog.NSLOG4J);
			List<Element> listEvent = (List<Element>) root.getChildren(
					ConstanteXmlLog.EVENT, nsLog4j);
			Element messagesPrelog = new Element("messages");
			for (Element event : listEvent) {
				Element elEvent = event;
				String level = elEvent.getAttributeValue(ConstanteXmlLog.LEVEL);
				elEvent.removeAttribute(ConstanteXmlLog.LEVEL);
				Element message = elEvent.getChild(ConstanteXmlLog.MESSAGE,
						nsLog4j);
				message.setNamespace(Namespace.NO_NAMESPACE);
				message.setName(ConstanteXmlLog.MESSAGE);
				elEvent.setNamespace(Namespace.NO_NAMESPACE);
				elEvent.setName(level);

				Element messagePrelog = new Element("message");
				messagePrelog.setAttribute("type", level);
				messagePrelog.setText(message.getText());
				messagesPrelog.addContent(messagePrelog);
			}
			root.removeNamespaceDeclaration(nsLog4j);

			Element returncodeRoot = new Element(ConstanteXmlLog.RETURNCODE);
			Element returncodeID = new Element(ConstanteXmlLog.ID);
			String[] returncode = LogManagement.getReturnCodeArr();
			returncodeID.setText(returncode[1]);
			returncodeRoot.addContent(returncodeID);
			Element returncodemsg = new Element(ConstanteXmlLog.MESSAGE);
			returncodemsg.setText(returncode[0]);
			returncodeRoot.addContent(returncodemsg);

			Element realRootNode = new Element(LogManagement.getToolname());
			log.removeContent(root);
			realRootNode.addContent(messagesPrelog);
			//realRootNode.addContent(root);
			realRootNode.addContent(returncodeRoot);
			log.addContent(new Comment("Created by " + Constante.NOMAPPLICATION
					+ " " + Constante.VERSIONAPPLICATION + ": " + getTime()));
			log.addContent(new Comment(getPrintedLogMsgLevelComment()));
			log.addContent(realRootNode);
		
		
			Format format = Format.getPrettyFormat();
			format.setEncoding("UTF-8");
			FileOutputStream output = new FileOutputStream(logdefault);
	        XMLOutputter serializer  = new XMLOutputter(format);
	        serializer.output(log, output);
	        output.flush();
	        output.close();
			
			
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		logbkp.delete();
	}

	/**
	 * Clears content of the log4j generated file.
	 */
	public static void purgeLog() {

		try {
			// create backup
			File backupFile = new File(logdefault.getPath()
					+ Constante.PURGEDNAME);
			backupLog(backupFile);
			// purge log
			FileWriter fr = new FileWriter(logdefault);
			BufferedWriter br = new BufferedWriter(fr);
			br.write("");
			br.flush();
			br.close();
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	/**
	 * Verifies whether log file contains info.
	 * 
	 * @param logFile
	 *            - file to verify.
	 * @return true - if there is at least one line written in the file.
	 */
	private static boolean isEmpty(final File logFile) {

		boolean vrf = true;
		Closeable resource = null;
		try {
			FileReader fr = new FileReader(logFile);
			resource = fr;
			BufferedReader br = new BufferedReader(fr);
			resource = br;
			String readline = null;
			while ((readline = br.readLine()) != null) {
				if (!readline.equals("")) {
					vrf = false;
				}
			}
			br.close();
		} catch (Exception e) {
			System.out.println(e.getMessage());
		} finally {
			try {
				resource.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return vrf;
	}

	/**
	 * Get system time, format: yyyy.mm.dd HH:mm:ss.
	 * 
	 * @return system time.
	 */
	private static String getTime() {
		String time = "";
		Calendar cal = new GregorianCalendar();
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH) + 1;
		int day = cal.get(Calendar.DAY_OF_MONTH);
		int hour = cal.get(Calendar.HOUR_OF_DAY);
		int min = cal.get(Calendar.MINUTE);
		int sec = cal.get(Calendar.SECOND);
		time = year + "." + month + "." + day + " " + hour + ":" + min + ":"
				+ sec;
		return time;
	}

	/**
	 * Get comment of printed log message level(s).
	 * 
	 * @return comment.
	 */
	private static String getPrintedLogMsgLevelComment() {
		String comment = "";
		String mode = LogManagement.getMode();
		String level = LMConfiguration.getLevel();
		if (mode.equals(Constante.MODESEPARATE)) {
			comment = "Output Log Message Level: " + level;
		} else if (mode.equals(Constante.MODETHRESHOLD)) {
			if (level.equals(ConstanteLevel.ALL)
					|| level.equals(ConstanteLevel.TRACE)) {
				comment = "Output Log Message Level: " + ConstanteLevel.TRACE
						+ "," + ConstanteLevel.DEBUG + ","
						+ ConstanteLevel.INFO + "," + ConstanteLevel.WARN + ","
						+ ConstanteLevel.ERROR + "," + ConstanteLevel.FATAL;
			} else if (level.equals(ConstanteLevel.DEBUG)) {
				comment = "Output Log Message Level: " + ConstanteLevel.DEBUG
						+ "," + ConstanteLevel.INFO + "," + ConstanteLevel.WARN
						+ "," + ConstanteLevel.ERROR + ","
						+ ConstanteLevel.FATAL;
			} else if (level.equals(ConstanteLevel.INFO)) {
				comment = "Output Log Message Level: " + ConstanteLevel.INFO
						+ "," + ConstanteLevel.WARN + ","
						+ ConstanteLevel.ERROR + "," + ConstanteLevel.FATAL;
			} else if (level.equals(ConstanteLevel.WARN)) {
				comment = "Output Log Message Level: " + ConstanteLevel.WARN
						+ "," + ConstanteLevel.ERROR + ","
						+ ConstanteLevel.FATAL;
			} else if (level.equals(ConstanteLevel.ERROR)) {
				comment = "Output Log Message Level: " + ConstanteLevel.ERROR
						+ "," + ConstanteLevel.FATAL;
			} else if (level.equals(ConstanteLevel.FATAL)) {
				comment = "Output Log Message Level: " + ConstanteLevel.FATAL;
			} else if (level.equals(ConstanteLevel.OFF)) {
				comment = "Output Log Message Level: " + ConstanteLevel.OFF
						+ ", No Output Log Message.";
			}
		}
		return comment;
	}
}
